/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WeWorkFinanceSdk_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Slice_t {
    pub buf: *mut ::std::os::raw::c_char,
    pub len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Slice_t() {
    const UNINIT: ::std::mem::MaybeUninit<Slice_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Slice_t>(),
        16usize,
        concat!("Size of: ", stringify!(Slice_t))
    );
    assert_eq!(
        ::std::mem::align_of::<Slice_t>(),
        8usize,
        concat!("Alignment of ", stringify!(Slice_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Slice_t),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Slice_t),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MediaData {
    pub outindexbuf: *mut ::std::os::raw::c_char,
    pub out_len: ::std::os::raw::c_int,
    pub data: *mut ::std::os::raw::c_char,
    pub data_len: ::std::os::raw::c_int,
    pub is_finish: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_MediaData() {
    const UNINIT: ::std::mem::MaybeUninit<MediaData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MediaData>(),
        32usize,
        concat!("Size of: ", stringify!(MediaData))
    );
    assert_eq!(
        ::std::mem::align_of::<MediaData>(),
        8usize,
        concat!("Alignment of ", stringify!(MediaData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outindexbuf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MediaData),
            "::",
            stringify!(outindexbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MediaData),
            "::",
            stringify!(out_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MediaData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MediaData),
            "::",
            stringify!(data_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_finish) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MediaData),
            "::",
            stringify!(is_finish)
        )
    );
}
pub type MediaData_t = MediaData;
extern "C" {
    pub fn NewSdk() -> *mut WeWorkFinanceSdk_t;
}
extern "C" {
    #[doc = " 初始化函数\n Return值=0表示该API调用成功\n\n @param [in]  sdk\t\t\tNewSdk返回的sdk指针\n @param [in]  corpid      调用企业的企业id，例如：wwd08c8exxxx5ab44d，可以在企业微信管理端--我的企业--企业信息查看\n @param [in]  secret\t\t聊天内容存档的Secret，可以在企业微信管理端--管理工具--聊天内容存档查看\n\n\n @return 返回是否初始化成功\n      0   - 成功\n      !=0 - 失败"]
    pub fn Init(
        sdk: *mut WeWorkFinanceSdk_t,
        corpid: *const ::std::os::raw::c_char,
        secret: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 拉取聊天记录函数\n Return值=0表示该API调用成功\n\n\n @param [in]  sdk\t\t\t\tNewSdk返回的sdk指针\n @param [in]  seq\t\t\t\t从指定的seq开始拉取消息，注意的是返回的消息从seq+1开始返回，seq为之前接口返回的最大seq值。首次使用请使用seq:0\n @param [in]  limit\t\t\t一次拉取的消息条数，最大值1000条，超过1000条会返回错误\n @param [in]  proxy\t\t\t使用代理的请求，需要传入代理的链接。如：socks5://10.0.0.1:8081 或者 http://10.0.0.1:8081\n @param [in]  passwd\t\t\t代理账号密码，需要传入代理的账号密码。如 user_name:passwd_123\n @param [in]  timeout\t\t\t超时时间，单位秒\n @param [out] chatDatas\t\t返回本次拉取消息的数据，slice结构体.内容包括errcode/errmsg，以及每条消息内容。示例如下：\n\n{\"errcode\":0,\"errmsg\":\"ok\",\"chatdata\":[{\"seq\":196,\"msgid\":\"CAQQ2fbb4QUY0On2rYSAgAMgip/yzgs=\",\"publickey_ver\":3,\"encrypt_random_key\":\"ftJ+uz3n/z1DsxlkwxNgE+mL38H42/KCvN8T60gbbtPD+Rta1hKTuQPzUzO6Hzne97MgKs7FfdDxDck/v8cDT6gUVjA2tZ/M7euSD0L66opJ/IUeBtpAtvgVSD5qhlaQjvfKJc/zPMGNK2xCLFYqwmQBZXbNT7uA69Fflm512nZKW/piK2RKdYJhRyvQnA1ISxK097sp9WlEgDg250fM5tgwMjujdzr7ehK6gtVBUFldNSJS7ndtIf6aSBfaLktZgwHZ57ONewWq8GJe7WwQf1hwcDbCh7YMG8nsweEwhDfUz+u8rz9an+0lgrYMZFRHnmzjgmLwrR7B/32Qxqd79A==\",\"encrypt_chat_msg\":\"898WSfGMnIeytTsea7Rc0WsOocs0bIAerF6de0v2cFwqo9uOxrW9wYe5rCjCHHH5bDrNvLxBE/xOoFfcwOTYX0HQxTJaH0ES9OHDZ61p8gcbfGdJKnq2UU4tAEgGb8H+Q9n8syRXIjaI3KuVCqGIi4QGHFmxWenPFfjF/vRuPd0EpzUNwmqfUxLBWLpGhv+dLnqiEOBW41Zdc0OO0St6E+JeIeHlRZAR+E13Isv9eS09xNbF0qQXWIyNUi+ucLr5VuZnPGXBrSfvwX8f0QebTwpy1tT2zvQiMM2MBugKH6NuMzzuvEsXeD+6+3VRqL\"}]}\n\n\n @return 返回是否调用成功\n      0   - 成功\n      !=0 - 失败"]
    pub fn GetChatData(
        sdk: *mut WeWorkFinanceSdk_t,
        seq: ::std::os::raw::c_ulonglong,
        limit: ::std::os::raw::c_uint,
        proxy: *const ::std::os::raw::c_char,
        passwd: *const ::std::os::raw::c_char,
        timeout: ::std::os::raw::c_int,
        chatDatas: *mut Slice_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief 解析密文.企业微信自有解密内容\n @param [in]  encrypt_key, getchatdata返回的encrypt_random_key,使用企业自持对应版本秘钥RSA解密后的内容\n @param [in]  encrypt_msg, getchatdata返回的encrypt_chat_msg\n @param [out] msg, 解密的消息明文\n @return 返回是否调用成功\n      0   - 成功\n      !=0 - 失败"]
    pub fn DecryptData(
        encrypt_key: *const ::std::os::raw::c_char,
        encrypt_msg: *const ::std::os::raw::c_char,
        msg: *mut Slice_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 拉取媒体消息函数\n Return值=0表示该API调用成功\n\n\n @param [in]  sdk\t\t\t\tNewSdk返回的sdk指针\n @param [in]  sdkFileid\t\t从GetChatData返回的聊天消息中，媒体消息包括的sdkfileid\n @param [in]  proxy\t\t\t使用代理的请求，需要传入代理的链接。如：socks5://10.0.0.1:8081 或者 http://10.0.0.1:8081\n @param [in]  passwd\t\t\t代理账号密码，需要传入代理的账号密码。如 user_name:passwd_123\n @param [in]  indexbuf\t\t媒体消息分片拉取，需要填入每次拉取的索引信息。首次不需要填写，默认拉取512k，后续每次调用只需要将上次调用返回的outindexbuf填入即可。\n @param [in]  timeout\t\t\t超时时间，单位秒\n @param [out] media_data\t\t返回本次拉取的媒体数据.MediaData结构体.内容包括data(数据内容)/outindexbuf(下次索引)/is_finish(拉取完成标记)\n\n\n @return 返回是否调用成功\n      0   - 成功\n      !=0 - 失败"]
    pub fn GetMediaData(
        sdk: *mut WeWorkFinanceSdk_t,
        indexbuf: *const ::std::os::raw::c_char,
        sdkFileid: *const ::std::os::raw::c_char,
        proxy: *const ::std::os::raw::c_char,
        passwd: *const ::std::os::raw::c_char,
        timeout: ::std::os::raw::c_int,
        media_data: *mut MediaData_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief 释放sdk，和NewSdk成对使用\n @return"]
    pub fn DestroySdk(sdk: *mut WeWorkFinanceSdk_t);
}
extern "C" {
    pub fn NewSlice() -> *mut Slice_t;
}
extern "C" {
    #[doc = " @brief 释放slice，和NewSlice成对使用\n @return"]
    pub fn FreeSlice(slice: *mut Slice_t);
}
extern "C" {
    #[doc = " @brief 为其他语言提供读取接口\n @return 返回buf指针\n     !=NULL - 成功\n     NULL   - 失败"]
    pub fn GetContentFromSlice(slice: *mut Slice_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn GetSliceLen(slice: *mut Slice_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NewMediaData() -> *mut MediaData_t;
}
extern "C" {
    pub fn FreeMediaData(media_data: *mut MediaData_t);
}
extern "C" {
    pub fn GetOutIndexBuf(media_data: *mut MediaData_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn GetData(media_data: *mut MediaData_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn GetIndexLen(media_data: *mut MediaData_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetDataLen(media_data: *mut MediaData_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn IsMediaDataFinish(media_data: *mut MediaData_t) -> ::std::os::raw::c_int;
}
